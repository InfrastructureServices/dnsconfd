import logging
import os
import os.path
import shutil


class SystemManager:
    HEADER = "# Generated by dnsconfd\n"

    def __init__(self, config: dict):
        """ Maintain /etc/resolv.conf including backups

        :param config: Dict containing configuration of Dnsconfd
        :type config: dict
        """
        # File contents
        self._backup = None
        # Original symlink destination
        self._backup_link = None
        self._resolv_conf_path = config["resolv_conf_path"]
        self._listen_address = config["listen_address"]
        self._resolver_options = config["resolver_options"]
        self.lgr = logging.getLogger(self.__class__.__name__)

    def set_resolvconf(self) -> bool:
        """ Replace resolv.conf content with our config and perform backup

        :return: True if operation was successful, otherwise False
        :rtype: bool
        """
        try:
            if os.path.islink(self._resolv_conf_path):
                self._backup_link = os.readlink(self._resolv_conf_path)
                self.lgr.debug("Resolvconf is symlink to %s",
                               self._backup_link)
                os.unlink(self._resolv_conf_path)
            else:
                self.lgr.debug("Resolvconf is plain file")
                with open(self._resolv_conf_path, "r",
                          encoding="utf-8") as orig_resolv:
                    self._backup = orig_resolv.read()
        except FileNotFoundError as e:
            self.lgr.error("Not present resolvconf: %s", e)
            return False
        except OSError as e:
            self.lgr.error("OSError encountered while reading "
                           "resolv.conf %s", e)
            return False
        return True

    def _get_resolvconf_string(self, search_domains=None):
        if search_domains is None:
            search_domains = []
        conf = self.HEADER
        if self._resolver_options:
            conf += f"options {self._resolver_options}\n"
        conf += f"nameserver {self._listen_address}\n"
        if search_domains:
            conf += f"search {' '.join(search_domains)}\n"
        return conf

    def revert_resolvconf(self) -> bool:
        """ Return resolv.conf to its original state

        :return: True if operation was successful, otherwise False
        :rtype: bool
        """
        if self._backup is not None:
            try:
                with open(self._resolv_conf_path, "w",
                          encoding="utf-8") as new_resolv:
                    new_resolv.write(self._backup)
            except OSError as e:
                self.lgr.error("OSError encountered while writing "
                               "resolv.conf %s", e)
                return False
        elif self._backup_link is not None:
            try:
                os.unlink(self._resolv_conf_path)
                os.symlink(self._backup_link, self._resolv_conf_path)
            except OSError as e:
                self.lgr.error("OSError encountered while linking "
                               "back resolv.conf: %s", e)
                return False
        return True

    def update_resolvconf(self, search_domains: list[str]) -> bool:
        """ Insert search domains into resolv.conf

        :param search_domains: Domains for insertion
        :type search_domains: list[str]
        :return: True if operation was successful, otherwise False
        :rtype: bool
        """
        self.lgr.info("Updating resolvconf with domains %s", search_domains)
        try:
            with open(self._resolv_conf_path, "w",
                      encoding="utf-8") as new_resolv:
                new_resolv.write(self._get_resolvconf_string(search_domains))
        except OSError as e:
            self.lgr.error("OSError encountered while writing "
                           "resolv.conf: %s", e)
            return False
        return True

    def chown_resolvconf(self, user: str) -> bool:
        """ Change ownership of resolv.conf to given user

        :param user: user that should own resolv.conf
        :return: True when operation was successful, otherwise False
        :rtype: bool
        """
        try:
            if os.path.islink(self._resolv_conf_path):
                os.unlink(self._resolv_conf_path)
            open(self._resolv_conf_path, 'w+', encoding="utf-8").close()
            shutil.chown(self._resolv_conf_path, user, None)
        except OSError as e:
            self.lgr.error("Failed to change ownership of resolv.conf: %s",
                           e)
            return False
        except LookupError as e:
            self.lgr.error("User %s was not found, does it exist? %s",
                           user, e)
        return True
